<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Kinco HMI WebGL 工厂模型 Demo</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #0b0f19; color: #e6e6e6; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    header { padding: 10px 12px; font-size: 14px; background: #101625; border-bottom: 1px solid #1e293b; display: flex; align-items: center; gap: 12px; }
    header button { appearance: none; background: #1f2937; border: 1px solid #334155; color: #e5e7eb; padding: 6px 10px; border-radius: 10px; font-size: 12px; cursor: pointer; }
    header button:active { transform: translateY(1px); }
    #canvas { width: 100%; height: 100%; display: block; touch-action: none; }
    .hint { opacity: .8; }
    #errorBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(200,50,50,0.9); color: #fff; padding: 16px 20px; border-radius: 12px; display: none; font-size: 14px; z-index: 10; }
    #moveButtons { position: fixed; bottom: 30px; right: 30px; display: grid; grid-template-areas: ". up ." "left reset right" ". down ."; gap: 6px; }
    #moveButtons button { width: 50px; height: 50px; background-color: #1f2937; color: white; border: 1px solid #334155; border-radius: 6px; font-size: 18px; cursor: pointer; }
    #instructions { margin: 16px; font-size: 14px; line-height: 1.6; color: #cbd5e1; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <strong>工厂 3D Demo</strong>
    <span class="hint">单指拖动旋转 · 双指捏合缩放 · 双击复位</span>
    <button id="resetBtn">复位视角</button>
    <button id="fitViewBtn">适配视图</button>
    <button id="autorotateBtn">自动旋转：关</button>
  </header>
  <canvas id="canvas"></canvas>
  <div id="errorBox">❌ 工厂模型加载失败，请检查 index.glb 文件是否放在与 index.html 同目录。</div>
</div>

<div id="moveButtons">
  <button id="upBtn" style="grid-area: up;">↑</button>
  <button id="downBtn" style="grid-area: down;">↓</button>
  <button id="leftBtn" style="grid-area: left;">←</button>
  <button id="rightBtn" style="grid-area: right;">→</button>
  <button id="resetPosBtn" style="grid-area: reset;">⟳</button>
</div>

<div id="instructions">
  <h3>运行本地服务器步骤：</h3>
  <ol>
    <li>确保已安装 <code>Python</code> (Windows 10/11 通常自带)。</li>
    <li>把 <code>index.html</code>、<code>index.glb</code> 和 <code>libs</code> 文件夹放到同一目录。</li>
    <li>在该目录下打开命令行 (PowerShell 或 CMD)，输入：<br>
      <code>python -m http.server 8000</code>
    </li>
    <li>浏览器访问：<a href="http://localhost:8000/index.html" target="_blank">http://localhost:8000/index.html</a></li>
    <li>确认 3D 模型加载成功。</li>
  </ol>
</div>

<!-- 使用 three.js 非模块版 -->
<script src="./libs/three.js"></script>
<script src="./libs/OrbitControls.js"></script>
<script src="./libs/GLTFLoader.js"></script>
<script>
  const canvas = document.getElementById('canvas');
  const errorBox = document.getElementById('errorBox');

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight - document.querySelector('header').offsetHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f19);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / (window.innerHeight - document.querySelector('header').offsetHeight), 0.1, 2000);
  camera.position.set(6, 4, 8);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.minDistance = 0.5;
  controls.maxDistance = 2000;
  controls.autoRotate = false;
  controls.autoRotateSpeed = 1.0;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 5);
  scene.add(dirLight);

  let model;
  let modelCenter = new THREE.Vector3(0,0,0);
  const initialPos = new THREE.Vector3(0,0,0);
  let modelOffset = initialPos.clone();

  // =============== 公共方法 ===============
  function fitView() {
    if (!model) return;
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    const fitOffset = 1.2;
    const maxSize = Math.max(size.x, size.y, size.z);
    const fitHeightDistance = maxSize / (2 * Math.tan((Math.PI * camera.fov) / 360));
    const fitWidthDistance = fitHeightDistance / camera.aspect;
    const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);

    camera.position.set(center.x + distance, center.y + distance, center.z + distance);
    controls.target.copy(center);
    controls.update();
  }

  function resetView() {
    camera.position.set(6,4,8);
    controls.target.set(0,0,0);
    controls.update();
  }

  // =============== 加载模型 ===============
  const loader = new THREE.GLTFLoader();
  loader.load('./index.glb', (gltf) => {
    model = gltf.scene;
    scene.add(model);

    // 模型居中
    const box = new THREE.Box3().setFromObject(model);
    modelCenter = box.getCenter(new THREE.Vector3());
    model.position.sub(modelCenter);

    // 初始就做一次适配
    fitView();

  }, undefined, (err) => {
    console.error('加载工厂模型出错:', err);
    errorBox.style.display = 'block';
  });

  function updateModelPosition() {
    if (model) {
      model.position.set(modelOffset.x, modelOffset.y, modelOffset.z).sub(modelCenter);
    }
  }

  function continuousMove(deltaX, deltaY) {
    const interval = setInterval(() => {
      modelOffset.x += deltaX;
      modelOffset.y += deltaY;
      updateModelPosition();
    }, 100);
    return interval;
  }

  let moveInterval;
  function addHoldListener(button, deltaX, deltaY) {
    button.addEventListener('mousedown', () => { moveInterval = continuousMove(deltaX, deltaY); });
    button.addEventListener('mouseup', () => { clearInterval(moveInterval); });
    button.addEventListener('mouseleave', () => { clearInterval(moveInterval); });
    button.addEventListener('touchstart', () => { moveInterval = continuousMove(deltaX, deltaY); });
    button.addEventListener('touchend', () => { clearInterval(moveInterval); });
  }

  addHoldListener(document.getElementById('upBtn'), 0, 0.1);
  addHoldListener(document.getElementById('downBtn'), 0, -0.1);
  addHoldListener(document.getElementById('leftBtn'), -0.1, 0);
  addHoldListener(document.getElementById('rightBtn'), 0.1, 0);

  document.getElementById('resetPosBtn').addEventListener('click', () => { modelOffset.copy(initialPos); updateModelPosition(); });

  // =============== 按钮事件 ===============
  document.getElementById('fitViewBtn').addEventListener('click', fitView);
  document.getElementById('resetBtn').addEventListener('click', resetView);

  const autoBtn = document.getElementById('autorotateBtn');
  autoBtn.addEventListener('click', () => {
    controls.autoRotate = !controls.autoRotate;
    autoBtn.textContent = "自动旋转：" + (controls.autoRotate ? "开" : "关");
  });

  // 双击复位
  renderer.domElement.addEventListener('dblclick', resetView);

  function resize() {
    const h = window.innerHeight - document.querySelector('header').offsetHeight;
    const w = window.innerWidth;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  resize();
  animate();
</script>
</body>
</html>
